# 程序地址空间

进程地址空间图

![image-20220116222258292](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220116222258292.png)



**checkarea.c**

```c
#include<stdio.h>    
#include<unistd.h>    
#include<stdlib.h>    
    
int glo_val=0;    
int uninit_val;    
    
int main(int argc,char* argv[],char* env[])    
{    
  //代码区    
  printf("code addr:%p\n\n",main);    
  //字符常量区    
  const char* p="hello world!";    
  printf("read only addr:%p\n\n",p);    
  //已初始化全局变量区    
  printf("glo_val addr:%p\n",&glo_val);    
  //未初始化全局变量区    
  printf("uninit addr:%p\n\n",&uninit_val);    
  //堆区    
  char* q=(char*)malloc(10);    
  printf("heap addr:%p\n\n",q);    
  //栈区    
  printf("stack addr:%p\n",&p);    
  printf("stack addr:%p\n\n",&q);    
  //命令行参数    
  printf("args addr:%p\n",argv[0]);    
  printf("args addr:%p\n\n",argv[argc-1]);    
  //环境变量    
  printf("env addr:%p\n\n",env[0]);    
    
  //测试static修饰的变量在哪块区域    
  static int a=0;    
  printf("static addr:%p\n\n",&a);                                                                                                                        
    return 0;
}    
```

运行：![image-20220116222454360](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220116222454360.png)

将其与代码一一对应起来：

![image-20220116223649233](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220116223649233.png)



## 虚拟地址

```c
#include<stdio.h>    
#include<unistd.h>      
   
int glo_val=0;    
 
int main()    
{    
  int ret=fork();    
  if(ret>0)    
  {    
  	//parent    
    while(1)    
    {    
      sleep(1);    
      printf("\n i am father::glo_val:%d, &glo_val:%p\n",glo_val,&glo_val);   
    }    
  }    
  else    
  {    
    //child    
    glo_val=100;    
    while(1)    
    {    
      sleep(1);                                                      
      printf("\n i am son::   glo_val:%d, &glo_val:%p\n",glo_val,&glo_val);   
    }    
  }    
  return 0;    
}
```

运行：

![image-20220116224857353](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220116224857353.png)



> 观察运行结果，为什么两个的地址一样，但是值却不同？？？
>
> 到这里引出虚拟内存，显然同一块空间不可能有两个值，因为我们从学C语言起（没学系统前）**取到的地址都是虚拟地址**，而不是真正的物理地址，我们在语言层面拿到的都是虚拟地址。

![image-20220116230350224](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220116230350224.png)

> - 虚拟内存本质上也不过是结构体(mm_struct)（~~源码没找到，建议Linux源码版本别下太高了，不好找😥~~），在mm_struct里规定了地址的起始，比如0x00000000到0x11111111这块代表代码区
>
> - 假如内存是4G，每个进程都会以为自己拥有了4G的内存（虚拟）
>
>   > 讲个小故事帮助理解，一个身价十亿的富豪，有十个私生子，他对每个私生子说：百年之后我把自己的所有财产都归到你名下，私生子之间并不知道对方的存在，所以每个私生子都会以为自己拥有十亿，私生子每次向自己的父亲要钱父亲都会给予回应
>   >
>   > 再比如你把十万存入银行，你以为自己有的十万，你每次要一两万都能到从中取出来，你以为你拥有十万，但是你每次取得并不是原先的十万。
>   >
>   > 正如进程需要内存空间，他是觉得自己拥有全部内存的。
>
> - 页表就相当于一种映射关系
>
> - 虚拟地址是靠操作系统提供的，虚拟内存与物理内存的转化靠的是操作系统
> - 进程地址空间不是内存，而是随着进程一直存在（因为本身就只是C语言模拟出来的程序而已)



## 四个问题

虚拟地址空间vs物理空间之间的关系





块注释（hjkl)



![image-20220116155948824](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220116155948824.png)



![image-20220116172000550](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220116172000550.png)